# 旋转数组的最小数字



## 题目

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

示例 1：

```
输入：[3,4,5,1,2]
输出：1
```

示例 2：

```
输入：[2,2,2,0,1]
输出：0
```



## 思路

我们注意到旋转之后的数组实际上可以划分为两个排序的子数组，而前面的数组的元素都大于或者等于后面子数组的元素。而且最小的元素就是这两个子数组的分界线。

我们试着用二分查找，用lo、hi两个指针分别指向首元素和尾元素。我们考虑尾元素：

- 如果`numbers[hi] > numbers[mid]`，则mid属于后一子序列，我们要找的元素在[lo, mid]之间。

- 如果`numbers[hi] < numbers[mid]`，则mid属于前一子序列，我们要找的元素的(mid, hi]之间。

- 如果`numbers[hi] == numbers[mid]`，这并不好判断。例如：[1, 0, 1, 1, 1]；[1, 1, 1, 0, 1]；[1, 1, 1, 1, 1]。既有可能在前，又有可能在后，又有可能是mid。所以我们令`hi--`，同时mid也会自动更新，进行逐一检查。



如果我们考虑首元素呢？似乎可行，只需要将上面的条件将hi改成lo，再把大小于号改变一下就行了。

但是我们需要考虑一种特殊情况，即如果一个子数组为空，相当于numbers是一个递增的有序序列，那按照计划`numbers[lo] < numbers[mid]`时`lo = mid`。这时就会跳过目标元素，最后得到错误的结果。



## 复杂度分析

- 时间复杂度：平均时间复杂度是O(logn)。最坏情况下，即如果数组元素都相同，则时间复杂度为O(n)。
- 空间复杂度：O(1)。