# 机器人的运动范围

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

**示例 1：**

```
输入：m = 2, n = 3, k = 1
输出：3
```

**示例 2：**

```
输入：m = 3, n = 1, k = 0
输出：1
```



## 思考

可以用回溯法，深度优先遍历（DFS）。

- **深度优先遍历**：即先沿着一个方向搜索到底，在回溯至上一个节点沿着另一个方向搜索，以此类推。

- **剪枝**：在搜索中，遇到位数和>=目标值、次元素已访问，则应立即返回，称为可行性剪枝

- 递归**终止条件**：

- 1. 当行列索引越界
  2. 数位和超出目标值k
  3. 当前元素已访问时

  返回0，代表不计入可达解

- 递归： 

- 1. 标记当前单元格，将其设为true
  2. 搜索下一单元格，只计算下、右两方向的元素，并开始下层递归

- **回溯返回值**：返回`1 + 右方搜索的可达解总数 + 下方搜索的可达解总数`，代表本单元递归搜索的可达解总数。



## 复杂度分析

- 时间复杂度：O(mn)。最坏情况下机器人需要遍历所有单元格
- 空间复杂度：O(mn)。visited存储所有单元格可访问情况。



## 其他方法

广度优先遍历（BFS）

- **DFS/BFS**：两者目标都是遍历整个矩阵，不同点在于搜索顺序不同。DFS 是朝一个方向走到底，再回退，以此类推；BFS 则是按照“平推”的方式向前搜索。
- **BFS 实现：** 通常利用队列实现广度优先遍历。



- **初始化**： 将机器人初始点 (0, 0)(0,0) 加入队列 queue ；
- **迭代终止条件**： queue 为空。代表已遍历完所有可达解。
- **迭代工作**：
- 1. 单元格出队： 将队首单元格的 索引、数位和 弹出，作为当前搜索单元格。
  2. 判断是否跳过： 若 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，执行 continue 。
  3. 标记当前单元格 ：将单元格索引 (i, j) 存入 Set visited 中，代表此单元格 已被访问过 。
  4. 单元格入队： 将当前元素的 下方、右方 单元格的 索引、数位和 加入 queue 

- **返回值**：visited的长度 ，即可达解的数量。

