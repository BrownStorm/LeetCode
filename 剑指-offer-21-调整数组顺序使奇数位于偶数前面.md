# 调整数组顺序使奇数位于偶数前面

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

示例：

```
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
```



## 思考

使用两个指针，一个`odd`指向未排序的第一个奇数；一个`eve`指向已排序的第一个偶数。`odd`与`eve`的寻找可以使用`STL`中的`find_if`函数。

初始化：

- `odd`为整个序列的第一个奇数
- `eve`为整个序列的第一个偶数

初始化后检查`odd`或`eve`是否有等于`nums.end()`的情况，有则表明原始序列本来有序，不需要其他处理，直接返回初始序列即可。

每次循环：

- `odd`为未排序的序列中的第一个奇数，（未排序的序列：$[++odd, nums/end())$)
- `eve`为已排序的序列中的第一个偶数，（已排序的序列虽为$[nums.begin(), odd)$，但考虑到效率问题，遂从$[eve, odd)$中寻找）
- 检查未排序序列中是否有奇数（即，`odd == nums.end()`），若无奇数则循环结束，有奇数则交换`odd`与`eve`所指元素

## 复杂度分析

- 时间复杂度：相当于从头至尾遍历一次，$O(n)$
- 空间复杂度：只使用了`odd`与`eve`两个额外空间，$O(1)$



## 其他方法

可以使用`STL`标准库函数`sort`，将二元谓词改写成如果奇数在偶数前返回`true`，即：

```cpp
sort(nums.begin(), nums.end(), [](int a, int b) { return a % 2 != 0 && b % 2 == 0; });
```

