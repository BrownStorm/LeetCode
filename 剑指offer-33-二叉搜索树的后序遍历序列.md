# 二叉搜索树的后序遍历

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。

 

参考以下这颗二叉搜索树：

         5
        / \
       2   6
      / \
     1   3


示例 1：

```
输入: [1,6,3,2,5]
输出: false


示例 2：

```
输入: [1,3,2,6,5]
输出: true
```





## 思考

二叉搜索树，它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树。

根据二叉搜索树的定义，可以通过**递归**，判断所有子树的正确性，若所有子树都正确，则此序列为二叉搜索树的后序遍历。

递归解析：

- **终止条件**： 当 `i >= j` ，说明此子树节点数量`<=1`，无需判别正确性，因此直接返回`true`；
- **递归工作**：
  1. 划分左右子树：遍历后序遍历的`[i, j]`区间元素，寻找第一个大于根节点的节点，索引记为m。此时可分出左子树`[i, m - 1]`，右子树`[m, j - 1]`，根节点`j`。
  2. 判断是否为二叉搜索树：左子树区间都应小于根节点，右子树都应大于根节点。但因为在第一步划分左右子树的过程中已经完成，所以只需判断右子树即可。

- **返回值**：因为所有子树都满足才可判定正确，所以用与运算符相连。`t == j && func(i, m - 1) && func(m, j - 1)`

## 复杂度

- 时间复杂度：$ O(N^2) $。每次调用`func`会减去一个节点，所以递归占用$O(N)$。最差情况下退化成链表，每次遍历都需要遍历所有节点，占用$O(N)$
- 空间复杂度：$O(N)$。最差情况下退化成链表，递归深度将达到$N$







