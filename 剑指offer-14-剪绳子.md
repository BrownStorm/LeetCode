# 剪绳子

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例 1：

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```




示例 2:

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```



## 思路

因为`m > 1`，意味着至少剪一段。假设，一段n长的绳子，第一刀剪在长度为i处，则当前的结果是`f(n) = f(i) * f(n - i)`。于是我们发现这个问题被分解成有很多重复部分的子问题，意味着可以使用**动态规划**。

动态转移方程为`f(n) = max(f(i), i + 1) * max(f(j - i), j - i - 1)`

因为最少剪一刀，所以遇到已经剪过一刀的情况，当前`dp[i]`，可以一刀不剪，所以如果当`i + i > dp[i]`时应一刀都不剪，所以会有上面的max判断。

最后返回dp数组的最后一个值



## 复杂度分析

- 空间复杂度：双重循环：O(n^2)
- 空间复杂度：需要长度为n的dp数组：O(n)





## 其他方法

![image-20210422171329583](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210422171329583.png)

![image-20210422171346530](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210422171346530.png)