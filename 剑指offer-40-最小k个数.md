# 最小k个数



输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

 

示例 1：

```
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
```


示例 2：

```
输入：arr = [0,1,2,1], k = 1
输出：[0]
```



## 思路

**堆**

我们用一个大根堆实时维护数组的前 k 小值。首先将前 k 个数插入大根堆中，随后从第 k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。在下面的代码中，由于 C++ 语言中的堆（即优先队列）为大根堆，我们可以这么做。



## 复杂度分析

- 时间复杂度：$O(nlogk)$。由于大根堆实时维护前 kk 小值，所以插入删除都是 $O(logk)$ 的时间复杂度，最坏情况下数组里 n 个数都会插入，所以一共需要 $O(nlogk)$ 的时间复杂度。
- 空间复杂度：$O(k)$