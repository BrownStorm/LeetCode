# 复杂链表的复制

请实现`copyRandomList`函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个`next`指针指向下一个节点，还有一个`random`指针指向链表中的任意节点或者`null`。

示例：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```



## 思考

本题主要问题在于如何对新链表的`random`指针进行赋值

方法一：

可以将新旧两链表中同等位置节点的地址建立起映射关系`m`，然后通过`m`对`randmo`指针进行赋值

总共需要两个循环：

- 第一个循环，构建单链表，即对新链表的`next`指针进行赋值，并建立起映射关系`m`
- 第二个循环，对新链表的`random`指针进行进行赋值。



方法二：

考虑构建 `原节点 1 -> 新节点 1 -> 原节点 2 -> 新节点 2 -> …… `的拼接链表，如此便可在访问原节点的`random`指向节点的同时找到新对应新节点的`random`指向节点。

**算法流程**

1. **复制各节点，构建拼接链表:**
   - 设原链表为`node1 -> node2 -> ……`。拼接后的链表如下：`node1 -> newNode1 -> node2 -> newNode2 -> ……`

2. **构建新链表各节点的 `random` 指向：**
   - 当访问原节点 `node` 的随机指向节点 `node->random` 时，对应新节点 `node->next` 的随机指向节点为 `node->random->next` 。

3. **拆分链表：**
   - 遍历执行 `pre.next = pre.next.next` 和 `cur.next = cur.next.next` 将两链表拆分开。



## 复杂度

方法一：

- 时间复杂度：$O(N)$
- 空间复杂度：$O(N)$



方法二：

- 时间复杂度：$O(N)$
- 空间复杂度：$O(1)$

