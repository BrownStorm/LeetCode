# 快速幂

实现函数`double myPow(double x, int n)`，求x的n次方，不得使用库函数，同时也不用考虑大数问题。





## 思路（1）：递归

1. 如果n == 0，到达递归终止条件，返回1

2. 如果n < 0，最终结果为$1/x^{-n}$
   
3. 如果n为奇数，最终结果为$x * x ^ {n - 1}$
   
4. 如果n为偶数，最终结果为$x ^ {2*(n/2)}$



## 复杂度分析

递归几次就有多大的复杂度，最多递归次数是n为负数且n为奇数的时候，比n为正数且为偶数的情况多递归2次，常数级别的复杂度忽略不计；主要就看n为偶数的时候，这时最多递归次数为n的二进制位数，也就是log(底数为2)。

- 时间复杂度：$O(logn)$
- 空间复杂度：$O(logn)$

## 思路（2）：迭代

1. 首先处理n为负的情况，把x取一下倒数并且把n变成正数即可（但需要注意的是`-INT_MIN`比`INT_MAX`大1）

2. 以n=18为例解释一下迭代的过程： 18的二进制数为10010。即$ x^{18} = x ^ {16} * x^{2} $
   
   可以循环右移，每次循环都对x做`x *= x`，如果末位是1，则做`res *= x`。在n=18这个例子中：
   
3. 令循环体为`x *= x`，`n >> 1`

   - 循环1次可得$x^2$
   - 循环2次，末位为1，则把$x^2$乘到结果，可得$x^4$
   - 循环3次可得$x^8$
   - 循环4次可得$x^{16}$
   - 循环5次，末位为1，则把$x^{16}$乘到结果

## 复杂度分析

- 时间复杂度：$O(logn)$
- 空间复杂度：$O(1)$



## 其他方法

我想到的方法是，以x = 2.0;n = 10为例：

1. 首先计算$x^1$~$x^{10}$之间最接近$x^{10}$的，$x^{x^2}$，即$x^1$、$x^2$、$x^4$、$x^8$、$x^{16}$……。因为每次都是`x *= x;`所以可以以指数形式快速增长。这里得出的是$2^8$。
2. 而后再向后寻找距10 - 8最近的$x^i$数。这里得到的是$2^2$
3. 因为2 + 8 == 10;所以循环结束

如果是负数，则先做一次再将n取反，以防溢出

- 时间复杂度：$O(logn)$
- 空间复杂度：$O(logn)$