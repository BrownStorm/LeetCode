# 重建二叉树

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

## 递归

### 思路

对于任意一颗树而言，前序遍历的形式总是

```
[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]
```

即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是

```
[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]
```

只要我们在中序遍历中**定位**到**根节点**，那么我们就可以分别知道左子树和右子树中的节点数目。

这样一来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两棵子树接到根节点的左右位置。



### 递归结束条件

首先考虑子树只有一个节点的时候 ：
因为当子树只有一个节点时，`preorder_left==preorder_right`，`size_left==0`。
在下一次递归时`preorder_left+=1`，而`preorder_right=preorder_left+size_left`。这时`preorder_left>preorder_right`，所以递归结束条件是：`preorder_left>preorder_right`

### 建立哈希映射

建立哈希映射，以便快速的从中序遍历中找到根节点，否则每次寻找根节点都需要一次遍历。

### 复杂度分析

时间复杂度：O(n)，其中n是树中的节点个数。

空间复杂度：O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中h是树的高度）的空间表示递归时栈空间。这里 h < n，所以总空间复杂度为 O(n)。



## 迭代

