# 顺时针打印矩阵

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

示例 1：

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```


示例 2：

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```



## 思路

以5*3的矩阵为例，需要顺时针读取矩阵，则读取方向先后为“右、下、左、上、左”；读取的长度依次是5、2、4、1、3

![image-20210521160951513](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210521160951513.png)

我们需要解决两个问题：

1. 读取矩阵的方向
2. 在一次不改变方向的读取过程中，总共需要读多少个数据。

读取方向：

因为是按顺时针方向读取，所以是按“右、下、左、上”的顺序循环，直至所有数据都读完。

我们可以设置一个参数`status`，用来保存当前状态下的读取方向，一次读取完成后，再按照“右、下、左、上”的顺序修改`status`。



读取多少数据：

在这个例子中，读取长度依次是5、2、4、1、3，一眼看过去没有什么规律。

我们设矩阵的长宽分别为`len1`和`len2`。则此例中`len1 = 5`，`len2 = 3`。

我们依次将长度减去相应的步数得：0、1、1、2、2

可以得出规律，即，`step`两轮循环+1；可以认为一轮循环加0.5，只不过需要再加一个int强转，即，`int(0.5)`、`int(1)`、`int(1.5)`、`int(2)`、`int(2.5)`。`step`初始值为0.5。



双层循环，外层循环依据当前状态选择移动方向并将step增加0.5；内层循环计算循环次数`lenx - int(step)`并读取数据。



## 复杂度分析

- 时间复杂度：$O(mn)$
- 空间复杂度：$O(1)$。除了输出数组外，空间复杂度是常数







