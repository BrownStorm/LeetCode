# 柱状图中的最大矩形



给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

 

![image-20210705135350889](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210705135350889.png)

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 `[2,1,5,6,2,3]`。

![image-20210705135406836](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210705135406836.png)

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 `10` 个单位。

**示例:**

```
输入: [2,1,5,6,2,3]
输出: 10
```



# 思考



**单调栈**

因为矩形面积 = 高 * 宽

所以我们可以每次固定高，计算可能的最大宽度；然后依次枚举高，得出每次高的最大面积，最后得出最大面积。

步骤如下：

- 首先我们枚举某一根柱子$i$作为高$h=heights[i]$
- 随后我们需要进行向左右两边扩展，使得扩展到的柱子的高度均不小于$h$。换句话说，我们需要找到左右两侧最近的高度小于$h$的柱子，这样这两根柱子之间（不包括其本身）的所有柱子高度均不小于$h$，并且就是$i$能够扩展到的最远范围


如果我们每枚举一个`heights[i]`就遍历一次，会导致时间复杂度过高，所以这里就需要使用两个单调栈，一个从左往右遍历，计算当前位置`i`左边的第一个比它小的位置；而另一个从右往左遍历，计算当前位置`i`右边第一个比它小的位置。

如例图所示，`left[2] = 1`，`right[2] = 4`；这时的面积为`(right[2] - left[2] - 1) * heights[2]`

## 复杂度分析

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

