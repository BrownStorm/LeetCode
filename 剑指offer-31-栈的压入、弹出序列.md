# 栈的压入、弹出序列

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。



示例 1：

```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```


示例 2：

```
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```



## 思路

首先想到能否只用分别指向两个序列中的指针模拟入栈出栈。想了想应该不行，设指向入栈序列的首元素指针为`p1`，指向出栈序列首元素指针为`p2`，则入栈为`p1++`，出栈表示`p2++;p1--`。如果出栈再入栈则`p1`会访问到已经访问过的元素，除非可以记录下入栈出栈的序号，但这样繁不胜繁。

所以使用一个辅助栈来实现模拟这两个入栈出栈的序列。

- 入栈操作：按照压栈序列的顺序执行
- 出栈操作：每次入栈后，判断栈顶元素与弹出序列当前的元素是否相等，如果相等则进入内层循环，弹出栈顶元素，直至条件不符。



## 复杂度

- 时间复杂度：$O(N)$。分别遍历两个序列，最多进行$2N$次出入栈操作。
- 空间复杂度：$O(N)$。需要使用辅助栈，最多需要存储N个元素。

