# 二叉树中和为某一值的路径

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

 

示例:
给定如下二叉树，以及目标和 target = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:

```
[
   [5,4,11,2],
   [5,8,4,5]
]
```



## 思路

可以通过先序遍历计算每个节点当前路径下的和，然后再进行一次先序遍历，查看是否有符合条件的路径。我想这样实在是太傻了，可以记录路径。当检查当前路径和是否是目标值时，将当前节点值加入路径；检查完之后再将节点值从路径中删除。

所以这个题的主要问题是两点：先序遍历、路劲记录

- **先序遍历：** 按照 “根、左、右” 的顺序，遍历树的所有节点。

- **路径记录**： 在先序遍历中，记录从根节点到当前节点的路径。当路径节点值的和等于目标值`target`且当前节点为叶子节点时，将此路径加入结果列表。

  

`func(TreeNode* root, int target)`函数：

- 递推参数：当前节点`root`，当前目标值`target`
- 终止条件：当前节点`root`为空，直接返回
- 递推工作：
  1. 路径更新：将当前节点值`root->val`加入`path`
  2. 目标值更新：`target -= root->val`
  3. 正确路径记录：当路径节点值之和等于目标值`target`且当前节点为叶子节点时，将此路径`path`加入`ans`
  4. 先序遍历：递归左右子节点
  5. 路径恢复：向上回溯前，需要将当前节点从路径`path`中删除，即执行`path.erase(--path.end())`。易知，当前节点为叶子节点时，删除`path`的最后一个值一定是自身；因为调用函数最后都会删除最后的节点；所以每次执行`path.erase(--path.end())`一定是删除自身。



## 复杂度

- 时间复杂度：$O(N)$。遍历所有节点
- 空间复杂度：$O(N)$。最差情况下，树退化成链表，`path`需存储所有节点。



