# 1～n 整数中 1 出现的次数



输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。

例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

 

示例 1：

```
输入：n = 12
输出：5
```


示例 2：

```
输入：n = 13
输出：6
```





## 思路



最直接的思路是对1~n的每一个整数都按位判断它是否为1。但这显然复杂度过高。

之后我想这个复杂度过高是因为没有保存之前计算过的信息，比如说45和345，这两个数的1的个数都是0，他们有两位是重复出现的，只有一位是需要判断的，所以只需要判断新的这一位就好。所以我们可以只判断最高位是否是1，如果是1，则对之前保存的数据加1即可。而且（对于此例）我们可以在`299 < 当前判断数字 < 400`时只需要判断一次即可，因为每次都做整除运算也是很耗时的。之后我自以为找到了正确的解法，但代码写出来调试，还是超时了……



**正确的写法**



其实如果需要计算1~n所有的整数中1的个数，并不需要计算所有的数，只需要看最后一个数n即可。

不难得出“计算1~n所有的整数中1的个数”等价于“1~n所有整数中，个位出现1的次数 + 十位出现1的次数 + ……”

例如12，`2 + 3 = 5`

![image-20210708110506095](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210708110506095.png)



我们定义三个变量分别表示：当前位`cur`，高位`high`（当前位左边），低位`low`（当前位右边）

再定义一个`digital`表示当前位是个十百千万等等中的哪一个（个位为1，十位为10，百位为100……）

对任意某一位的数，其取值范围为0~9，可以分为三类：

- `== 0`，如0。当前位出现1的个数为`high * digital`
- `== 1`，如1。当前位出现1的个数为`high * digital + 1 + low`
- `> 1`，如2、3、4、……。当前位出现1的个数为`(high + 1) * digital`



例如：2304、2314、2324

![image-20210708113338234](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210708113338234.png)



![image-20210708113351159](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210708113351159.png)



![image-20210708113359844](C:\Users\Admin\AppData\Roaming\Typora\typora-user-images\image-20210708113359844.png)



## 复杂度分析

- 时间复杂度：$O(logn)$。n有几位就计算几次，所以是以10为底n的对数。
- 空间复杂度：$O(1)$



